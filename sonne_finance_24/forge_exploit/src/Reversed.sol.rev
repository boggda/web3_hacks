// Decompiled by library.dedaub.com
// 2024.06.02 23:52 UTC
// Compiled using the solidity compiler version 0.7.6


// Data structures and variables inferred from the use of storage instructions
address stor_0_0_19; // STORAGE[0x0] bytes 0 to 19
address stor_1_0_19; // STORAGE[0x1] bytes 0 to 19
address stor_2_0_19; // STORAGE[0x2] bytes 0 to 19
address _owner; // STORAGE[0x3] bytes 0 to 19
address _bs; // STORAGE[0x4] bytes 0 to 19
uint160 veloPool; // STORAGE[0x5] bytes 0 to 19
uint160 stor_6_0_19; // STORAGE[0x6] bytes 0 to 19
uint160 stor_7_0_19; // STORAGE[0x7] bytes 0 to 19
address unitroller; // STORAGE[0x9] bytes 0 to 19
uint160 stor_a_0_19; // STORAGE[0xa] bytes 0 to 19
address veloToken; // STORAGE[0xb] bytes 0 to 19
uint160 sonneToken; // STORAGE[0xc] bytes 0 to 19
address stor_e_0_19; // STORAGE[0xe] bytes 0 to 19



function 0x5f1870f5(address varg0, bytes varg1, uint256 varg2) public payable { 
    require(4 + (msg.data.length - 4) - 4 >= 96);
    0x2fe7(varg0);
    require(varg1 <= uint64.max);
    require(4 + varg1 + 31 < 4 + (msg.data.length - 4));
    assert(varg1.length <= uint64.max);
    v0 = new bytes[](varg1.length);
    assert(!((v0 + ((varg1.length + 31 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) + 32) > uint64.max) | (v0 + ((varg1.length + 31 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) + 32) < v0)));
    require(varg1.data + varg1.length <= 4 + (msg.data.length - 4));
    CALLDATACOPY(v0.data, varg1.data, varg1.length);
    v0[varg1.length] = 0;
    0x3035(varg2);
    require(address(tx.origin) == _owner);
    v1 = v2 = 0;
    while (v1 < v0.length) {
        MEM[v3.data + v1] = v0[v1];
        v1 = v1 + 32;
    }
    if (v1 > v0.length) {
        MEM[v3.data + v0.length] = 0;
    }
    v4, /* uint256 */ v5 = varg0.call(v3.data).value(varg2).gas(msg.gas);
    if (RETURNDATASIZE() != 0) {
        v6 = new bytes[](RETURNDATASIZE());
        RETURNDATACOPY(v6.data, 0, RETURNDATASIZE());
    }
    require(v4);
}

function owner() public nonPayable { 
    return _owner;
}

function hook(address varg0, uint256 amount0, uint256 amount1, bytes data) public nonPayable { 
    0xb42(data.length, data.data, amount1, amount0, varg0);
}

function 0xd3477d5f() public nonPayable { 
    require(bool(_bs.code.size));
    v0, /* address */ v1 = _bs.expo().gas(msg.gas);
    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v1 == address(v1));
    return address(v1) == address(this);
}

function 0x1c6(address varg0) private { 
    v0 = varg0.transfer(msg.sender, 2).gas(msg.gas);
    return ;
}

function 0x1c67(address varg0, address varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { 
    v0, /* uint256 */ v1 = varg1.balanceOf(address(varg4[0x1])).gas(msg.gas);
    MEM[v1d6a.data:v1d6a.data + 1990] = 0x608060405234801561001057600080fd5b506040516107c63803806107c68339818101604052810190610032919061047b565b3373ffffffffffffffffffffffffffffffffffffffff16634022ea3e8760018151811061005b57fe5b60200260200101516040518263ffffffff1660e01b815260040161007f919061060c565b600060405180830381600087803b15801561009957600080fd5b505af11580156100ad573d6000803e3d6000fd5b505050508673ffffffffffffffffffffffffffffffffffffffff1663c2998238876040518263ffffffff1660e01b81526004016100ea9190610650565b600060405180830381600087803b15801561010457600080fd5b505af1158015610118573d6000803e3d6000fd5b505050508560008151811061012957fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663c5ebeaec866040518263ffffffff1660e01b81526004016101699190610672565b600060405180830381600087803b15801561018357600080fd5b505af1158015610197573d6000803e3d6000fd5b50505050856001815181106101a857fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663852a12e3836040518263ffffffff1660e01b81526004016101e89190610672565b602060405180830381600087803b15801561020257600080fd5b505af1158015610216573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061023a9190610531565b508273ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33846040518363ffffffff1660e01b8152600401610276929190610627565b600060405180830381600087803b15801561029057600080fd5b505af11580156102a4573d6000803e3d6000fd5b505050508373ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33876040518363ffffffff1660e01b81526004016102e3929190610627565b600060405180830381600087803b1580156102fd57600080fd5b505af1158015610311573d6000803e3d6000fd5b505050508073ffffffffffffffffffffffffffffffffffffffff1663095ea7b3327fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6040518363ffffffff1660e01b8152600401610370929190610627565b600060405180830381600087803b15801561038a57600080fd5b505af115801561039e573d6000803e3d6000fd5b505050503373ffffffffffffffffffffffffffffffffffffffff16ff5b60006103ce6103c9846106be565b61068d565b905080838252602082019050828560208602820111156103ed57600080fd5b60005b8581101561041d57816104038882610427565b8452602084019350602083019250506001810190506103f0565b5050509392505050565b60008151905061043681610797565b92915050565b600082601f83011261044d57600080fd5b815161045d8482602086016103bb565b91505092915050565b600081519050610475816107ae565b92915050565b600080600080600080600060e0888a03121561049657600080fd5b60006104a48a828b01610427565b975050602088015167ffffffffffffffff8111156104c157600080fd5b6104cd8a828b0161043c565b96505060406104de8a828b01610466565b95505060606104ef8a828b01610427565b94505060806105008a828b01610427565b93505060a06105118a828b01610466565b92505060c06105228a828b01610427565b91505092959891949750929550565b60006020828403121561054357600080fd5b600061055184828501610466565b91505092915050565b60006105668383610581565b60208301905092915050565b61057b8161075f565b82525050565b61058a81610723565b82525050565b61059981610723565b82525050565b60006105aa826106fa565b6105b48185610712565b93506105bf836106ea565b8060005b838110156105f05781516105d7888261055a565b97506105e283610705565b9250506001810190506105c3565b5085935050505092915050565b61060681610755565b82525050565b60006020820190506106216000830184610590565b92915050565b600060408201905061063c6000830185610572565b61064960208301846105fd565b9392505050565b6000602082019050818103600083015261066a818461059f565b905092915050565b600060208201905061068760008301846105fd565b92915050565b6000604051905081810181811067ffffffffffffffff821117156106b4576106b3610795565b5b8060405250919050565b600067ffffffffffffffff8211156106d9576106d8610795565b5b602082029050602081019050919050565b6000819050602082019050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600061072e82610735565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061076a82610771565b9050919050565b600061077c82610783565b9050919050565b600061078e82610735565b9050919050565bfe5b6107a081610723565b81146107ab57600080fd5b50565b6107b781610755565b81146107c257600080fd5b5056fe;
    MEM[1990 + v2.data] = unitroller;
    MEM[1990 + v2.data + 32] = 224;
    MEM[1990 + v2.data + 224] = varg4.length;
    v3 = v4 = 1990 + v2.data + 224 + 32;
    v5 = v6 = varg4.data;
    v7 = v8 = 0;
    while (v7 < varg4.length) {
        MEM[v3] = address(MEM[v5]);
        v3 = v3 + 32;
        v5 = v5 + 32;
        v7 = v7 + 1;
    }
    MEM[1990 + v2.data + 64] = varg2;
    MEM[1990 + v2.data + 96] = varg0;
    MEM[1990 + v2.data + 128] = varg1;
    MEM[1990 + v2.data + 160] = v1 - 10 ** 20;
    MEM[1990 + v2.data + 192] = sonneToken;
    v9 = create.code(v2.data, v3 - v2.data).value(0);
    v10 = varg0.transfer(stor_2_0_19, varg3).gas(msg.gas);
    v11 = varg4.data;
    v12, /* uint256 */ v13, /* uint256 */ v14 = unitroller.liquidateCalculateSeizeTokens(address(varg4[0x0]), address(varg4[0x1]), varg3).gas(msg.gas);
    while (v14 != 1) {
        varg3 = varg3 * 15 / 10;
        v15 = varg4.data;
        v16, /* uint256 */ v17, /* uint256 */ v14 = unitroller.liquidateCalculateSeizeTokens(address(varg4[0x0]), address(varg4[0x1]), varg3).gas(msg.gas);
    }
    v18 = varg4.data;
    v19 = stor_2_0_19.call(uint32(0xf2bcae7d), address(v9), address(varg4[0x0]), address(varg4[0x1]), varg0, varg3).gas(msg.gas);
    v20, /* uint256 */ v21 = varg1.balanceOf(address(varg4[0x1])).gas(msg.gas);
    v22 = address(varg4[0x1]).mint(v21 + 1).gas(msg.gas);
    v23, /* uint256 */ v24 = address(varg4[0x1]).balanceOf(address(this)).gas(msg.gas);
    require(v24 == 2);
    return ;
}

function 0x296(address varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { 
    require(address(tx.origin) == _owner);
    if (stor_2_0_19 == address(0x0)) {
        veloPool = msg.data[varg4];
        stor_6_0_19 = msg.data[32 + varg4];
        stor_7_0_19 = msg.data[64 + varg4];
        unitroller = msg.data[varg3];
        veloToken = msg.data[32 + varg3];
        stor_2_0_19 = varg0;
        v0, /* address */ v1 = address(unitroller).getCompAddress().gas(msg.gas);
        sonneToken = v1;
        v2, /* address */ timelock = address(msg.data[varg3]).admin().gas(msg.gas);
        CALLDATACOPY(MEM[64], varg2, varg1);
        MEM[MEM[64] + varg1] = 0;
        v4, /* uint256 */ v5 = address(timelock).call(MEM[MEM[64]:MEM[64] + MEM[64] + v296arg0x1 - MEM[64]], MEM[MEM[64]:MEM[64]]).gas(msg.gas);
        require(v4);
    }
    v7, /* uint256 */ v8 = address(veloToken).balanceOf(address(veloPool)).gas(msg.gas);
    v9 = address(veloPool).swap(0, v8 - 10 ** 23, address(this), 48).gas(msg.gas);
    v10 = stor_0_0_19.withdraw(10 ** 18).gas(msg.gas);
    v11, /* uint256 */ v12 = address(tx.origin).call().value(10 ** 18).gas(msg.gas);
    if (RETURNDATASIZE() != 0) {
        v13 = new bytes[](RETURNDATASIZE());
        v12 = v13.data;
        RETURNDATACOPY(v12, 0, RETURNDATASIZE());
    }
    require(v11);
    return ;
}

function 0x2fe7(address varg0) private { 
    return ;
}

function 0x3035(uint256 varg0) private { 
    return ;
}

function receive() public payable { 
}

function 0x4022ea3e(address varg0) public nonPayable { 
    require(4 + (msg.data.length - 4) - 4 >= 32);
    0x2fe7(varg0);
    0x1c6(varg0);
}

function 0xb42(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { 
    require(address(tx.origin) == _owner);
    0xf8a(stor_9_0_19);
    v0 = stor_b_0_19.transfer(msg.sender, varg2).gas(msg.gas);
    v1, /* uint256 */ v2, /* uint256 */ v3, /* uint256 */ v4 = msg.sender.getReserves().gas(msg.gas);
    v5 = (1 + (1 + v2 * v3) / (10 ** 23 + varg2 - varg2 / 100) - v2 + 1) * 100 / 99;
    v6, /* uint256 */ v7 = stor_e_0_19.balanceOf(address(this)).gas(msg.gas);
    if (v7 < v5) {
        0x1aa4(0x1a055690d9db80000, stor_e_0_19, stor_0_0_19);
        v8 = stor_e_0_19.transfer(msg.sender, v5).gas(msg.gas);
    } else {
        v9 = stor_e_0_19.transfer(msg.sender, v5).gas(msg.gas);
    }
    return ;
}

function 0x51409e0d(uint256 varg0, uint256 varg1) public nonPayable { 
    require(4 + (msg.data.length - 4) - 4 >= 224);
    require(100 <= 4 + (msg.data.length - 4));
    require(164 <= 4 + (msg.data.length - 4));
    require(varg0 <= uint64.max);
    require(4 + varg0 + 31 < 4 + (msg.data.length - 4));
    require(varg0.length <= uint64.max);
    require(varg0.data + varg0.length <= 4 + (msg.data.length - 4));
    0x2fe7(varg1);
    0x296(varg1, varg0.length, varg0.data, 100, 4);
}

function bs() public nonPayable { 
    return _bs;
}

function 0xf8a(address varg0) private { 
    v0, /* uint256 */ v1 = varg0.getAllMarkets().gas(msg.gas);
    v2 = v3 = v1 + MEM[v1] + 32;
    assert(MEM[v1 + MEM[v1]] <= uint64.max);
    v4 = new uint256[](MEM[v1 + MEM[v1]]);
    assert(!((v4 + ((MEM[v1 + MEM[v1]] << 5) + 32) > uint64.max) | (v4 + ((MEM[v1 + MEM[v1]] << 5) + 32) < v4)));
    v5 = v6 = v4.data;
    require(v3 + (MEM[v1 + MEM[v1]] << 5) <= v1 + RETURNDATASIZE());
    v7 = v8 = 0;
    while (v7 < MEM[v1 + MEM[v1]]) {
        0x2fe7(MEM[v2]);
        MEM[v5] = MEM[v2];
        v5 = v5 + 32;
        v2 = v2 + 32;
        v7 = v7 + 1;
    }
    v10 = varg0.oracle().gas(msg.gas);
    stor_a_0_19 = v4[v4.length - 1];
    v12 = address(v10).getUnderlyingPrice(address(v4[v4.length - 1])).gas(msg.gas);
    v13 = veloToken.approve(address(v4[v4.length - 1]), uint256.max).gas(msg.gas);
    v15 = veloToken.balanceOf(address(this)).gas(msg.gas);
    veloToken.transfer(address(v4[v4.length - 1]), v15).gas(msg.gas);
    v17 = new uint256[](2);
    if (2) {
        CALLDATACOPY(v17.data, msg.data.length, 64);
    }
    assert(1 < v17.length);
    v17[1] = address(v4[v4.length - 1]);
    v18 = v19 = 0;
    while (v18 < v4.length - 1) {
        v21 = varg0.borrowGuardianPaused(address(v4[v18])).gas(msg.gas);
        if (!v21) {
            v23 = address(v4[v18]).underlying().gas(msg.gas);
            v25 = address(v10).getUnderlyingPrice(address(v4[v18])).gas(msg.gas);
            if (v25 != 0) {
                v26 = v17.data;
                v17[0] = address(v4[v18]);
                while (v18 >= v4.length) {
                    v28 = address(v4[v18]).getCash().gas(msg.gas);
                    v29 = v28 > v12 * 10 ** 20 / v25 * 108 / 100 * 10;
                    if (v29) {
                        v33 = veloToken.balanceOf(address(this)).gas(msg.gas);
                        veloToken.transfer(address(v4[v4.length - 1]), v33).gas(msg.gas);
                        v36 = veloToken.balanceOf(address(v4[v4.length - 1])).gas(msg.gas);
                        v38 = address(v4[v18]).getCash().gas(msg.gas);
                        if (v38 * v25 > v36 * v12 * 174 / 1000) {
                            v38 = v36 * v12 * 174 / 1000 / v25;
                        }
                        0x1c67(v23, veloToken, v38, v12 * 10 ** 20 / v25 * 108 / 100, v17);
                    }
                }
                throw();
            }
        }
        v18 += 1;
    }
    return ;
}
